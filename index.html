<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>

<style>
    html,
    body {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #c {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
    }

    .testBtn {
        position: absolute;
        left: 5pt;
        top: 5pt;
        display: block;
    }

    #options {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: block;
        padding: 5pt;
        background: #fff;
    }
</style>

<canvas id="c" onclick=""></canvas>

<!--<button id="flipAllBtn" class="testBtn">Flip All</button>-->
<button id="testBtn" class="testBtn">Test</button>

<div id="options">
    <p><input type="checkbox" id="option_gl1" name="option_gl1" /> <label for="option_gl1">Force WebGL 1</label></p>
    <p><input type="checkbox" id="option_pot" name="option_pot" /> <label for="option_pot"><s>(TODO) Use POT textures</s></label></p>
    <p><button id="startBtn">Start</button></p>
</div>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

<script>
    // This example uses THREE.CatmullRomCurve3 to create a path for a custom Keyframe Track position animation. // helper

    // Global Variables
    var canvas, scene, renderer, camera;
    var controls, raycaster, mouse, txtLoader, clock, delta = 0;
    var cardMesh;
    var /*card,*/ ground;
    
    // animation clips
    var flipUpsideClip, flipDownsideClip, addToHandClip;

    var cards = [];
    var cardObjs = [];

    var cameraAttachment;
    var handContainer;

    const colorDark = new THREE.Color(0xb0b0b0);
    const colorLight = new THREE.Color(0xffffff);
    const animationDuration = 1;

    start();
    document.querySelector('#startBtn').addEventListener('click', start, false);

    function start() {
        document.querySelector('#options').style.display = 'none';
        init({
            forceWebGL1: document.querySelector('#option_gl1').checked,
            usePOTTextures: document.querySelector('#option_pot').checked,
        });
    }

    function init(flags) {
        canvas = document.querySelector('#c');

        scene = new THREE.Scene();

        const rendererClass = flags.forceWebGL1 ? THREE.WebGL1Renderer : THREE.WebGLRenderer;
        renderer = new rendererClass({
            canvas: canvas,
            antialias: true
        });

        console.log("isWebGL2? " + renderer.capabilities.isWebGL2);
        renderer.shadowMap.enabled = true;
        //canvas = renderer.domElement;
        //document.body.appendChild(canvas);

        camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera.position.set(0, 4, -1.5);
        controls = new THREE.OrbitControls(camera, canvas);

        canvas.addEventListener('mousemove', onMouseMove, false);
        canvas.addEventListener('click', onMouseClick, false);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        txtLoader = new THREE.TextureLoader();
        clock = new THREE.Clock();

        // Lights
        initLights();

        cardMesh = createCardMesh();

        // animation clips
        flipUpsideClip = createFlipUpsideClip('faceup');
        flipDownsideClip = createFlipUpsideClip('facedown');
        addToHandClip = createAddToHandClip();

        // Cards
        for (var x = -3; x <= 3; x++) {
            for (var z = -3; z <= 3; z++) {
                var card = initCard();
                var group = new THREE.Group();
                group.add(card);
                scene.add(group);
                group.position.set(1.4 * x, 0, 2.1 * z);
                cards.push(card);
                cardObjs.push(group);
            }
        }

        // Camera attachment (container for camera-aligned objects)
        cameraAttachment = new THREE.Group();
        scene.add(cameraAttachment);
        updateCameraAttachment();

        // Hand container
        handContainer = new THREE.Group();
        cameraAttachment.add(handContainer);
        handContainer.position.set(0, -1.5, -4);

        /*addCardToHand(cardObjs[0], handContainer);
        addCardToHand(cardObjs[1], handContainer);
        addCardToHand(cardObjs[2], handContainer);
        addCardToHand(cardObjs[3], handContainer);
        addCardToHand(cardObjs[4], handContainer);
        addCardToHand(cardObjs[5], handContainer);*/

        // Ground
        initGround();

        render();

        //document.querySelector('#flipAllBtn').onclick = flipAllCards;
        document.querySelector('#testBtn').onclick = addCard;
    }

    function addCardToHand(cardObj, handContainer) {
        handContainer.attach(cardObj);
        var card = cardObj.children[0];
        card.actions.addToHand.play();
    }

    var testCount = 0;
    function addCard() {
        addCardToHand(cardObjs[testCount++], handContainer);
    }

    function updateCameraAttachment() {
        cameraAttachment.position.copy(camera.position);
        cameraAttachment.rotation.copy(camera.rotation);
    }

    function render() {
        if (resize(renderer)) {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        delta = clock.getDelta();
        for (var i = 0; i < cards.length; i++) {
            cards[i].mixer.update(delta);
        }

        updateCameraAttachment();

        var cardsInHandCount = handContainer.children.length;
        if (cardsInHandCount > 0) {
            var fanRadius = 5.0;
            var angleStep = -10;

            var aspectRatioLimit = 1.2;

            var maxFanSpreadAngle = 45;
            if (camera.aspect < aspectRatioLimit) {
                maxFanSpreadAngle *= camera.aspect / aspectRatioLimit;
            }
            var fanSpreadMul = maxFanSpreadAngle / (cardsInHandCount * Math.abs(angleStep));
            if (fanSpreadMul < 1) {
                angleStep *= fanSpreadMul;
            }

            var angleOffset = -0.5 * angleStep * (cardsInHandCount - 1);
            angleStep *= Math.PI / 180;
            angleOffset *= Math.PI / 180;
            var angleOffset2 = Math.PI / 2;
            for (var i = 0; i < cardsInHandCount; i++) {
                var cardObj = handContainer.children[i];

                var angle = angleOffset + i * angleStep;
                var depth = i * 0.02;
                var targetPos = new THREE.Vector3(
                    fanRadius * Math.cos(angleOffset2 + angle),
                    fanRadius * (Math.sin(angleOffset2 + angle) - 1),
                    depth
                );
                var targetEuler = new THREE.Euler(
                    Math.PI / 2,
                    Math.PI + angle,
                    0
                );
                var targetRot = new THREE.Quaternion();
                targetRot.setFromEuler(targetEuler);

                var t = 8.0 * delta;
                cardObj.position.lerp(targetPos, t);
                cardObj.quaternion.slerp(targetRot, t);
            }
        }

        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    function initLights() {
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
        var dirLight = new THREE.DirectionalLight(0xcceeff, 0.9);
        dirLight.castShadow = true;
        dirLight.position.setScalar(5);
        scene.add(dirLight, ambientLight);
    }

    function createCardMesh() {
        var faceUpTexture = txtLoader.load('card_front.jpg');
        var faceDownTexture = txtLoader.load('card_back.webp');
        // faceUpTexture.flipY = false;
        var darkMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
        var faceUpMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceUpTexture,
            shininess: 40
        });
        var faceDownMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceDownTexture,
            shininess: 40
        });
        var cardMesh = new THREE.Mesh(
            new THREE.BoxBufferGeometry(2, 0.04, 2),
            [
                darkMaterial, // left
                darkMaterial, // right
                faceDownMaterial, // facedown
                faceUpMaterial, // faceup
                darkMaterial, // 
                darkMaterial, // 
            ]
        );
        cardMesh.scale.x = 0.65;
        cardMesh.castShadow = true;
        return cardMesh;
    }

    function initCard() {
        var card = cardMesh.clone();

        //scene.add(card);

        // Animation 
        card.faceUp = false;
        card.mixer = new THREE.AnimationMixer(card);

        card.actions = {
            flipUpside: card.mixer.clipAction(flipUpsideClip),
            flipDownside: card.mixer.clipAction(flipDownsideClip),
            addToHand: card.mixer.clipAction(addToHandClip),
        };
        card.actions.flipUpside.loop = THREE.LoopOnce;
        card.actions.flipDownside.loop = THREE.LoopOnce;
        card.actions.flipUpside.clampWhenFinished = true;
        card.actions.flipDownside.clampWhenFinished = true;

        card.actions.addToHand.loop = THREE.LoopOnce;
        card.actions.addToHand.clampWhenFinished = true;

        return card;
    }

    function initGround() {
        ground = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(15, 15),
            new THREE.MeshStandardMaterial({
                map: txtLoader.load("hardwood2_diffuse.jpg"),
                metalness: 0,
                roughness: 1
            })
        );
        ground.geometry.rotateX(-Math.PI * 0.5);
        ground.position.set(0, -0.1, 0);
        ground.receiveShadow = true;
        scene.add(ground);
    }

    function createFlipUpsideClip(side) { // 'faceup' or 'facedown'
        // Create a keyframe track (i.e. a timed sequence of keyframes) for each animated property
        // Note: the keyframe track type should correspond to the type of the property being animated
        // Rotation
        var zAxis = new THREE.Vector3(0, 0, 1);

        if (side === 'faceup') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
        } else if (side === 'facedown') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
        }

        var quaternionKF = new THREE.QuaternionKeyframeTrack(
            '.quaternion',
            [0, animationDuration],
            [qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w]
        );

        // Position
        var pointsArr = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(1, 0.8, 0),
            new THREE.Vector3(0.7, 1.5, 0),
            new THREE.Vector3(0.15, 1.2, 0),
            new THREE.Vector3(0, 0, 0)
        ];
        if (side === 'facedown') {
            pointsArr.forEach(function (vec3, i) {
                vec3.x = -vec3.x;
            });
        }
        var CRC = new THREE.CatmullRomCurve3(pointsArr, false, 'catmullrom', 0.9);
        var CRCPoints = CRC.getPoints(50);

        //var helper = pointsHelper(CRCPoints);
        //scene.add(helper); // Optional helper for position curve

        var posArrFlat = [];
        for (var i = 0; i < CRCPoints.length; i++) {
            posArrFlat.push(CRCPoints[i].x, CRCPoints[i].y, CRCPoints[i].z);
        }

        var timesArr = [];
        var len = posArrFlat.length - 3;
        for (var j = 0; j < posArrFlat.length / 3; j++) {
            var x = ((animationDuration / len) * j * 3) + 0; // + delay
            timesArr.push(x);
        }

        var positionKF = new THREE.VectorKeyframeTrack(
            '.position',
            timesArr,
            posArrFlat,
            THREE.InterpolateSmooth
        );

        var flipUpsideClip = new THREE.AnimationClip('Flip', animationDuration, [positionKF, quaternionKF]);

        return flipUpsideClip;
    }

    function createAddToHandClip() {
        var posArrFlat = [
            0, 0, 0,
            0, 0, 2.5,
            0, 0, 0
        ];

        var timesArr = [];
        var len = posArrFlat.length - 3;
        for (var j = 0; j < posArrFlat.length / 3; j++) {
            var x = ((animationDuration / len) * j * 3) + 0; // + delay
            timesArr.push(x);
        }

        var positionKF = new THREE.VectorKeyframeTrack(
            '.position',
            timesArr,
            posArrFlat,
            THREE.InterpolateSmooth
        );

        var clip = new THREE.AnimationClip('AddToHand', animationDuration, [positionKF]);

        return clip;
    }

    function onMouseMove(evt) {
        
        /*if (raycast(card) == true) {
            card.material[2].color.set(colorLight);
            card.material[3].color.set(colorLight);
        } else {
            card.material[2].color.set(colorDark);
            card.material[3].color.set(colorDark);
        }*/
    }

    function onMouseClick(evt) {
        var card = raycastCards();
        if (card) {
            //flipCard(card);
        }
    }

    function flipCard(card) {
        if (card.faceUp) { // card faceup
            // so turn it facedown
            card.actions.flipUpside.stop();
            card.actions.flipDownside.play();
            card.faceUp = false;
        } else if (!card.faceUp) { // card facedown
            // so turn it faceup
            card.actions.flipDownside.stop();
            card.actions.flipUpside.play();
            card.faceUp = true;
        }
    }

    function flipAllCards() {
        for (var i = 0; i < cards.length; i++) {
            flipCard(cards[i]);
        }
    }

    function raycast(object) {
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject(object);
        if (intersects.length > 0) {
            return true;
        } else {
            return false;
        }
    }

    function raycastCards() {
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects(cards);
        if (intersects.length > 0) {
            return intersects[0].object;
        } else {
            return null;
        }
    }

    function pointsHelper(pointsArray) {
        var geometry = new THREE.BufferGeometry().setFromPoints(pointsArray);
        var material = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var curveObject = new THREE.Line(geometry, material);
        return curveObject;
    }

    function resize(renderer) {
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = canvas.clientWidth * pixelRatio | 0;
        const height = canvas.clientHeight * pixelRatio | 0;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
            renderer.setSize(width, height, false);
        }
        return needResize;
    }
</script>