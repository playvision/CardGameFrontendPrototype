<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>

<style>
    html,
    body {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #c {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
    }

    #testBtnContainer {
        position: absolute;
        right: 5pt;
        top: 40%;
        display: block;
        font-size: 20pt;
    }

    #testBtnContainer > div {
        display: block;
    }

    #options {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: block;
        padding: 5pt;
        background: #fff;
    }
</style>

<canvas id="c" onclick=""></canvas>

<!--<button id="flipAllBtn" class="testBtn">Flip All</button>-->
<div id="testBtnContainer">
    <button id="testBtn7" class="testBtn">6x6</button><br/>
    <button id="testBtn" class="testBtn">Draw</button><br/>
    <button id="testBtn2" class="testBtn">Draw (O1)</button><br/>
    <button id="testBtn3" class="testBtn">Draw (O2)</button><br/>
    <button id="testBtn4" class="testBtn">Draw (O3)</button><br/>
    <button id="testBtn5" class="testBtn">Draw (O4)</button><br/>
    <button id="testBtn6" class="testBtn">Draw (O5)</button><br/>
</div>

<div id="options">
    <p><input type="checkbox" id="option_gl1" name="option_gl1" /> <label for="option_gl1">Force WebGL 1</label></p>
    <p><input type="checkbox" id="option_pot" name="option_pot" /> <label for="option_pot"><s>(TODO) Use POT textures</s></label></p>
    <p><button id="startBtn">Start</button></p>
</div>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="Stats.js"></script>

<script type="x-shader/x-vertex" id="atlasQuadVertShader">
    attribute vec3 position;
    attribute vec2 uv;
    
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    uniform mediump vec2 leftBottom;
    uniform mediump vec2 rightTop;
    
    varying vec2 v_uv;
    
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    
      v_uv = vec2(uv.x, 1.0 - uv.y);
      v_uv = mix(leftBottom, rightTop, v_uv);
    }
</script>

<script type="x-shader/x-fragment" id="atlasQuadFragShader">
    precision mediump float;

    varying vec2 v_uv;

    uniform sampler2D map;
    uniform vec2 innerLeftBottom;
    uniform vec2 innerRightTop;
    uniform vec4 color;

    void main() {
      vec2 uv = clamp(v_uv, innerLeftBottom, innerRightTop);

      float lodBias = 0.0;
      if (uv != v_uv) {
        lodBias = -100.0;
      }

      uv.y = 1.0 - uv.y;
      gl_FragColor = texture2D(map, uv, lodBias) * color;
    }
</script>

<script type="x-shader/x-vertex" id="nineSliceVertShader">
    attribute vec3 position;
    attribute vec2 uv;
    
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    uniform mediump vec2 scale;
    
    varying vec2 v_uv;
    varying vec2 v_pos;
    
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    
      v_uv = uv;
      v_pos = (position.xy + 0.5) * scale;
    }
</script>

<script type="x-shader/x-fragment" id="nineSliceFragShader">
    precision mediump float;

    varying vec2 v_uv;
    varying vec2 v_pos;
    
    uniform vec2 scale;

    uniform sampler2D map;
    
    float remapValueInRange(float v, float a1, float b1, float a2, float b2) {
        return a2 + (v - a1) / (b1 - a1) * (b2 - a2);
    }

    void main() {
      vec2 uv = v_uv;
      
      float lEdge = 0.5;
      float rEdge = scale.x - 0.5;
      float bEdge = 0.5;
      float tEdge = scale.y - 0.5;
    
      if (v_pos.x < lEdge) {
        uv.x = v_pos.x;
      } else if(v_pos.x > rEdge) {
        uv.x = 1.0 - (scale.x - v_pos.x);
      } else {
        uv.x = remapValueInRange(v_pos.x, lEdge, rEdge, lEdge, 1.0 - (scale.x - rEdge));
      }

      if (v_pos.y < bEdge) {
        uv.y = v_pos.y;
      } else if(v_pos.y > tEdge) {
        uv.y = 1.0 - (scale.y - v_pos.y);
      } else {
        uv.y = remapValueInRange(v_pos.y, bEdge, tEdge, bEdge, 1.0 - (scale.y - tEdge));
      }

      gl_FragColor = texture2D(map, uv);
    }
</script>

<script>
    const gltfLoader = new THREE.GLTFLoader();

    var atlases = [];

    function loadAtlas(imageFileName, infoFileName) {
        var tex;
        return loadTexture(imageFileName).then(
            (texture) => {
                tex = texture;
                return fetch(infoFileName);
            }
        ).then(
            (response) => response.json()
        ).then((obj) => {
            //var obj = response.json();
            //var tex = txtLoader.load(imageFileName);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            obj.tex = tex;
            atlases.push(obj);
        });
    }

    function findQuadInAtlas(name) {
        for (var i = 0; i < atlases.length; i++) {
            var obj = atlases[i]['frames'][name];
            if (obj) {
                return {obj: obj, tex: atlases[i].tex};
            }
        }
        return null;
    }

    function getAtlasQuadInfo(name) {
        var atlasQuadMargin = 4;
        var facePlaneAtlasQuad = findQuadInAtlas(name);
        if (facePlaneAtlasQuad == null) {
            return null;
        }
        var facePlaneAtlasQuadRect = facePlaneAtlasQuad.obj["frame"];
        var facePlaneAtlasQuadSourceRect = facePlaneAtlasQuad.obj["spriteSourceSize"];
        var facePlaneAtlasQuadSourceSize = facePlaneAtlasQuad.obj["sourceSize"];
        var atlasImage = facePlaneAtlasQuad.tex.image;
        var innerRect = {
            left: (facePlaneAtlasQuadRect['x'] - atlasQuadMargin) / atlasImage.width,
            right: (facePlaneAtlasQuadRect['x'] + facePlaneAtlasQuadRect['w'] + atlasQuadMargin) / atlasImage.width,
            bottom: (facePlaneAtlasQuadRect['y'] - atlasQuadMargin) / atlasImage.height,
            top: (facePlaneAtlasQuadRect['y'] + facePlaneAtlasQuadRect['h'] + atlasQuadMargin) / atlasImage.height
        };
        var outerRect = {
            left: innerRect.left - facePlaneAtlasQuadSourceRect['x'] / atlasImage.width,
            bottom: innerRect.bottom - facePlaneAtlasQuadSourceRect['y'] / atlasImage.height
        };
        outerRect.right = outerRect.left + (facePlaneAtlasQuadSourceSize['w'] + 2 * atlasQuadMargin) / atlasImage.width;
        outerRect.top = outerRect.bottom + (facePlaneAtlasQuadSourceSize['h'] + 2 * atlasQuadMargin) / atlasImage.height;
        return {
            tex: facePlaneAtlasQuad.tex,
            innerRect: innerRect,
            outerRect: outerRect
        };
    }

    function loadTexture(url) {
        return new Promise(resolve => {
            txtLoader.load(url, resolve)
        });
    }

    var stats;

    // Global Variables
    var canvas, scene, renderer, camera;
    var controls, raycaster, mouse, txtLoader, clock, delta = 0;
    var cardMesh;
    var /*card,*/ ground;

    txtLoader = new THREE.TextureLoader();
    
    // animation clips
    var flipUpsideClip, flipDownsideClip, addToHandClip;

    var cards = [];
    var cardObjs = [];

    var deck = [];

    var transferSlot;

    var cameraAttachment;
    var handContainer;

    var draggedCardObj = null;
    var cardDragTouchId = null;

    var opponents = [];

    const colorDark = new THREE.Color(0xb0b0b0);
    const colorLight = new THREE.Color(0xffffff);
    const animationDuration = 1;

    const forward = new THREE.Vector3(0, 0, -1);
    const up = new THREE.Vector3(0, 1, 0);

    const tablePlane = new THREE.Plane(up, 0);

    start();
    document.querySelector('#startBtn').addEventListener('click', start, false);

    function start() {
        document.querySelector('#options').style.display = 'none';

        Promise.all([
            loadAtlas("Atlas2/texture-0.png", "Atlas2/texture-0.json"),
            loadAtlas("Atlas2/texture-1.png", "Atlas2/texture-1.json"),
            loadAtlas("Atlas2/texture-2.png", "Atlas2/texture-2.json")
        ]).then(() => gltfLoader.load(
            'card.glb',
            function (gltf) {
                var cardBody = gltf.scene.children[0];
                cardBody.name = "CardBody";
                cardBody.scale.set(0.004, 0.004, 0.004);
                cardBody.rotation.set(0, 0, 0);

                var facePlaneGeometry = new THREE.PlaneBufferGeometry(1, 1);
                var facePlaneMaterial = new THREE.RawShaderMaterial({
                    uniforms: {
                        color           : { value: new THREE.Vector4() },
                        map             : { value: null/*facePlaneAtlasQuad.tex*/ },
                        leftBottom      : { value: new THREE.Vector2(0, 0/*outerRect.left, outerRect.bottom*/) },
                        rightTop        : { value: new THREE.Vector2(0, 0/*outerRect.right, outerRect.top*/) },
                        innerLeftBottom : { value: new THREE.Vector2(0, 0/*innerRect.left, innerRect.bottom*/) },
                        innerRightTop   : { value: new THREE.Vector2(0, 0/*innerRect.right, innerRect.top*/) }
                    },
                    vertexShader: document.getElementById('atlasQuadVertShader').textContent,
                    fragmentShader: document.getElementById('atlasQuadFragShader').textContent,
                    transparent: true,
                    depthWrite: false
                });

                var facePlane = new THREE.Mesh(
                    facePlaneGeometry,
                    facePlaneMaterial
                );
                facePlane.rotation.set(Math.PI * 0.5, 0, 0);
                facePlane.scale.set(0.9, 1.5, 1);
                facePlane.position.set(0, -0.01, 0);
                facePlane.name = "FacePlane";
                gltf.scene.add(facePlane);

                var signPlane = new THREE.Mesh(
                    facePlaneGeometry,
                    facePlaneMaterial
                );
                signPlane.rotation.set(Math.PI * 0.5, 0, 0);
                signPlane.scale.set(0.4, 0.4, 1);
                signPlane.position.set(-0.5, -0.01, 0.8);
                signPlane.name = "SignPlane";
                gltf.scene.add(signPlane);

                var signPlane2 = new THREE.Mesh(
                    facePlaneGeometry,
                    facePlaneMaterial
                );
                signPlane2.rotation.set(Math.PI * 0.5, 0, Math.PI);
                signPlane2.scale.set(0.4, 0.4, 1);
                signPlane2.position.set(0.5, -0.01, -0.8);
                signPlane2.name = "SignPlane2";
                gltf.scene.add(signPlane2);

                var signPlane3 = new THREE.Mesh(
                    facePlaneGeometry,
                    facePlaneMaterial
                );
                signPlane3.rotation.set(Math.PI * 0.5, 0, 0);
                signPlane3.scale.set(0.2, 0.2, 1);
                signPlane3.position.set(-0.5, -0.01, 0.5);
                signPlane3.name = "SignPlane3";
                gltf.scene.add(signPlane3);

                var signPlane4 = new THREE.Mesh(
                    facePlaneGeometry,
                    facePlaneMaterial
                );
                signPlane4.rotation.set(Math.PI * 0.5, 0, Math.PI);
                signPlane4.scale.set(0.2, 0.2, 1);
                signPlane4.position.set(0.5, -0.01, -0.5);
                signPlane4.name = "SignPlane4";
                gltf.scene.add(signPlane4);

                cardMesh = gltf.scene;
                cardMesh.name = "Card";

                /*cardMesh = gltf.scene;
                cardMesh.scale.set(0.004, 0.004, 0.004);*/

                init({
                    forceWebGL1: document.querySelector('#option_gl1').checked,
                    usePOTTextures: document.querySelector('#option_pot').checked,
                });
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            },
            (error) => {
                console.log(error)
            }
        ));
    }

    function setCardFace(card, planeName, name, color) {
        var uniforms = card.getObjectByName(planeName).material.uniforms;
        var atlasQuadInfo = getAtlasQuadInfo(name);
        if (atlasQuadInfo != null) {
            uniforms.color.value = color;
            uniforms.map.value = atlasQuadInfo.tex;
            uniforms.leftBottom.value = new THREE.Vector2(atlasQuadInfo.outerRect.left, atlasQuadInfo.outerRect.bottom);
            uniforms.rightTop.value = new THREE.Vector2(atlasQuadInfo.outerRect.right, atlasQuadInfo.outerRect.top);
            uniforms.innerLeftBottom.value = new THREE.Vector2(atlasQuadInfo.innerRect.left, atlasQuadInfo.innerRect.bottom);
            uniforms.innerRightTop.value = new THREE.Vector2(atlasQuadInfo.innerRect.right, atlasQuadInfo.innerRect.top);
        } else {
            uniforms.map.value = null;
        }
    }

    function init(flags) {
        stats = new Stats();
        stats.showPanel( 0 );
        document.body.appendChild( stats.dom );
        stats.dom.style.cssText = 'position:absolute; top: 15%; left: 0;';

        canvas = document.querySelector('#c');

        scene = new THREE.Scene();

        const rendererClass = flags.forceWebGL1 ? THREE.WebGL1Renderer : THREE.WebGLRenderer;
        renderer = new rendererClass({
            canvas: canvas,
            antialias: true
        });

        console.log("isWebGL2? " + renderer.capabilities.isWebGL2);
        //renderer.shadowMap.enabled = true;
        //canvas = renderer.domElement;
        //document.body.appendChild(canvas);

        camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera.position.set(0, 8, 4);
        camera.rotation.set(-60 * Math.PI / 180, 0, 0);
        //controls = new THREE.OrbitControls(camera, canvas);

        canvas.addEventListener('mousemove', onMouseMove, false);
        canvas.addEventListener('click', onMouseClick, false);
        canvas.addEventListener('mousedown', onMouseDown, false);
        canvas.addEventListener('mouseup', onMouseUp, false);
        canvas.addEventListener('touchstart', onTouchStart, false);
        canvas.addEventListener('touchend', onTouchEnd, false);
        canvas.addEventListener('touchmove', onTouchMove, false);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        //txtLoader = new THREE.TextureLoader();
        clock = new THREE.Clock();

        // Lights
        initLights();

        //cardMesh = createCardMesh();

        // animation clips
        flipUpsideClip = createFlipUpsideClip('faceup');
        flipDownsideClip = createFlipUpsideClip('facedown');
        addToHandClip = createAddToHandClip();

        // Cards
        /*for (var x = -3; x <= 3; x++) {
            for (var z = -3; z <= 3; z++) {
                var card = initCard();
                var group = new THREE.Group();
                group.add(card);
                scene.add(group);
                group.position.set(1.4 * x, 0, 2.1 * z);
                cards.push(card);
                cardObjs.push(group);
            }
        }*/

        // Cards
        for (var i = 0; i < 52; i++) {
            var card = initCard();
            var group = new THREE.Group();
            group.add(card);
            scene.add(group);
            cards.push(card);
            cardObjs.push(group);
        }

        // Transfer slot
        initTransferSlot();

        // Deck
        var heightOfCardInDeck = 0.02;
        var deckPos = new THREE.Vector3(-3.1, 0, -1.5);
        var deckEuler = new THREE.Euler(
            Math.PI,
            0.05 * Math.PI,
            Math.PI
        );
        var deckRot = new THREE.Quaternion();
        deckRot.setFromEuler(deckEuler);
        for (var i = 0; i < cardObjs.length; i++) {
            deck.push(cardObjs[i]);
            var cardPos = new THREE.Vector3(0, i * heightOfCardInDeck, 0);
            cardPos.add(deckPos);
            cardObjs[i].position.copy(cardPos);
            cardObjs[i].quaternion.copy(deckRot);
        }

        // Camera attachment (container for camera-aligned objects)
        cameraAttachment = new THREE.Group();
        scene.add(cameraAttachment);
        updateCameraAttachment();

        // Hand container
        handContainer = new THREE.Group();
        cameraAttachment.add(handContainer);
        handContainer.position.set(0, -1.5, -4);

        // Other players' hand containers
        var numberOfOpponents = 5;
        var xOffset = 4.0;
        for (var i = 0; i < numberOfOpponents; i++) {
            opponentHandContainer = new THREE.Group();
            cameraAttachment.add(opponentHandContainer);
            opponentHandContainer.position.set(i * xOffset - 0.5 * xOffset * (numberOfOpponents - 1), 8, -18);
            opponentHandContainer.rotation.set(0, Math.PI, 0);
            opponents.push(
                {handContainer: opponentHandContainer}
            );
        }

        // Create 6 table slots
        for (var i = 0; i < 6; i++) {
            tableSlots.push(
                {bottom: null, top: null}
            );
        }

        // Ground
        initGround();

        render();

        //document.querySelector('#flipAllBtn').onclick = flipAllCards;
        document.querySelector('#testBtn').onclick = () => addCard(0);
        document.querySelector('#testBtn2').onclick = () => addCard(1);
        document.querySelector('#testBtn3').onclick = () => addCard(2);
        document.querySelector('#testBtn4').onclick = () => addCard(3);
        document.querySelector('#testBtn5').onclick = () => addCard(4);
        document.querySelector('#testBtn6').onclick = () => addCard(5);
        document.querySelector('#testBtn7').onclick = () => add6x6(3);
    }

    function addCardToHand(cardObj, handContainer) {
        handContainer.attach(cardObj);
        var card = cardObj.children[0];
        card.actions.addToHand.play();
    }

    function cardIsInHand(cardObj, handContainer) {
        return cardObj.parent == handContainer;
    }

    var tableSlots = [];

    function getFreeTableSlotIndex() {
        for (var i = 0; i < tableSlots.length; i++) {
            if (tableSlots[i].bottom === null) {
                return i;
            }
        }
        return -1;
    }

    function getNumberOfOccupiedTableSlots() {
        var i = getFreeTableSlotIndex();
        if (i == -1) {
            return tableSlots.length;
        }
        return i;
    }

    function tryPlaceCardOnTable(cardObj, slotIndex) {
        if (slotIndex == -1) {
            slotIndex = getFreeTableSlotIndex();
        }
        if (slotIndex == -1) {
            // No free slots
            return false;
        }
        var slot = tableSlots[slotIndex];
        if (slot.bottom === null) {
            slot.bottom = cardObj;
        } else if (slot.top === null) {
            slot.top = cardObj;
        } else {
            // The slot is occupied
            return false;
        }
        scene.attach(cardObj);
        return true;
    }

    function onCardDraggedOntoTable(cardObj) {
        tryPlaceCardOnTable(cardObj, -1);
    }

    function onDraggedCardReleased() {
        if (cardIsBeingDraggedOntoTable) {
            onCardDraggedOntoTable(draggedCardObj);
            cardIsBeingDraggedOntoTable = false;
        }
    }

    var locale = "ru";

    var cardSignLocalizations = {
        "ace":   () => (locale == "ru") ? "_ru" : "_de_en",
        "jack":  () => (locale == "en") ? "_en" : "_de_ru",
        "king":  () => "_de_en_ru",
        "queen": () => "_" + locale
    };

    function setCardIdentity(card, value, suit) {
        var signColor;
        if (suit == "diamonds" || suit == "hearts") {
            signColor = new THREE.Vector4(0.8, 0, 0, 1);
        } else {
            signColor = new THREE.Vector4(0, 0, 0, 1);
        }

        var pictureColor;
        if (value == "jack" || value == "king" || value == "queen") {
            pictureColor = new THREE.Vector4(1, 1, 1, 1);
        } else {
            pictureColor = signColor;
        }

        // Example: hearts_queen
        setCardFace(card, "FacePlane", suit + "_" + value, pictureColor);

        // Example: card_sign_king_white_de_en_ru
        var signLocalizedIdFn = cardSignLocalizations[value];
        var signFullId = "card_sign_" + value + "_white" + (signLocalizedIdFn ? signLocalizedIdFn() : "");
        setCardFace(card, "SignPlane", signFullId, signColor);

        // Example: icon_hearts_white
        setCardFace(card, "SignPlane3", "icon_" + suit + "_white", signColor); 
    }

    function randomInt(n) {
        return Math.floor(Math.random() * n);
    }

    // test
    function getRandomCardIdentity() {
        var suits = ["clubs", "diamonds", "hearts", "spades"];
        var values = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king", "ace"];  
        return {
            suit: suits[randomInt(suits.length)],
            value: values[randomInt(values.length)]
        };
    }
    
    //var testCount = 0;
    function addCard(playerId) {
        var cardObj = deck.pop();
        if (cardObj) {
            var card = cardObj.children[0];
            
            var identity = getRandomCardIdentity();
            setCardIdentity(card, identity.value, identity.suit);

            var hc = playerId == 0 ? handContainer : opponents[playerId-1].handContainer;
            addCardToHand(cardObj, hc);
        }
    }

    function add6x6() {
        for (var i = 0; i < 6; i++) {
            for (var j = 0; j < 6; j++) {
                addCard(i);
            }
        }
    }

    function updateCameraAttachment() {
        cameraAttachment.position.copy(camera.position);
        cameraAttachment.rotation.copy(camera.rotation);
    }

    function render() {
        stats.begin();

        if (resize(renderer)) {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        delta = clock.getDelta();
        for (var i = 0; i < cards.length; i++) {
            cards[i].mixer.update(delta);
        }

        var transferSlotIsActive = true;

        const tableSlotsPerRow = 3;
        const offsetBetweenCols = 1.5;
        const offsetBetweenRows = 2.1;
        const centerPosition = new THREE.Vector3(0, 0, -1.5);
        var numProperTableSlots = getNumberOfOccupiedTableSlots();
        var numTableSlots = numProperTableSlots;
        if (transferSlotIsActive) {
            numTableSlots++;
        }
        var numRows = ~~(numTableSlots / tableSlotsPerRow) + ((numTableSlots % tableSlotsPerRow > 0) ? 1 : 0);
        for (var i = 0; i < numTableSlots; i++) {
            var slot = null;
            
            if (i <= numProperTableSlots - 1) {
                slot = tableSlots[i];
            }

            var row = ~~(i / tableSlotsPerRow);
            var col = i % tableSlotsPerRow;
            var numColsInRow = (row < numRows - 1)
                ? tableSlotsPerRow
                : (numTableSlots % tableSlotsPerRow || tableSlotsPerRow);

            var xOffset = -0.5 * offsetBetweenCols * (numColsInRow - 1);
            var zOffset = -0.75 * offsetBetweenRows * (numRows - 1);

            var targetPos = new THREE.Vector3(
                xOffset + col * offsetBetweenCols,
                0.01,
                zOffset + row * offsetBetweenRows
            );
            targetPos.add(centerPosition);

            var targetEuler = new THREE.Euler(
                0,//Math.PI / 2,
                0,//Math.PI,
                Math.PI
            );
            var targetRot = new THREE.Quaternion();
            targetRot.setFromEuler(targetEuler);

            var lerpFactor = clamp(8.0 * delta, 0, 1);

            if (slot) {
                slot.bottom.position.lerp(targetPos, lerpFactor);
                slot.bottom.quaternion.slerp(targetRot, lerpFactor);
            } else {
                transferSlot.position.lerp(targetPos, lerpFactor);
            }
        }

        updateCameraAttachment();

        updateHandContainer(handContainer, true);
        for (var i = 0; i < opponents.length; i++) {
            updateHandContainer(opponents[i].handContainer, false);
        }

        updateDeck();

        renderer.render(scene, camera);

        stats.end();

        requestAnimationFrame(render);
    }

    function updateHandContainer(handContainer, playerHand) {
        var cardsInHandCount = handContainer.children.length;
        if (cardsInHandCount > 0) {
            var aspectRatioLimitForPositionAdjustment = 1.0;
            var aspectRatioLimitForSpreadAngleAdjustment = 1.4;

            var additionalFanOffset = new THREE.Vector3(0, 0, 0);
            var additionalFanOffsetFactor = 0;
            var maxAdditionalFanOffsetFactor = 0.8;
            if (playerHand && camera.aspect < aspectRatioLimitForPositionAdjustment) {
                additionalFanOffsetFactor = aspectRatioLimitForPositionAdjustment / camera.aspect - 1;
                if (additionalFanOffsetFactor > maxAdditionalFanOffsetFactor) {
                    additionalFanOffsetFactor = maxAdditionalFanOffsetFactor;
                }
                additionalFanOffset.set(0, -1.0 * additionalFanOffsetFactor, -1.0 * additionalFanOffsetFactor);
            }

            var fanRadius = 5.0;
            var angleStep = -10;

            var maxFanSpreadAngle = playerHand ? 45 : 30;
            if (playerHand && camera.aspect < aspectRatioLimitForSpreadAngleAdjustment) {
                maxFanSpreadAngle *= camera.aspect / aspectRatioLimitForSpreadAngleAdjustment;
            }
            var fanSpreadMul = maxFanSpreadAngle / (cardsInHandCount * Math.abs(angleStep));
            if (fanSpreadMul < 1) {
                angleStep *= fanSpreadMul;
            }

            var angleOffset = -0.5 * angleStep * (cardsInHandCount - 1);
            angleStep *= Math.PI / 180;
            angleOffset *= Math.PI / 180;
            var angleOffset2 = Math.PI / 2;
            for (var i = 0; i < cardsInHandCount; i++) {
                var cardObj = handContainer.children[i];

                var angle = angleOffset + i * angleStep;
                var depth = i * 0.02;
                var targetPos = new THREE.Vector3(
                    fanRadius * Math.cos(angleOffset2 + angle),
                    fanRadius * (Math.sin(angleOffset2 + angle) - 1),
                    depth
                );
                targetPos.add(additionalFanOffset);
                var targetEuler = new THREE.Euler(
                    Math.PI / 2,
                    /*Math.PI*/ 0 + angle,
                    Math.PI
                );
                var targetRot = new THREE.Quaternion();
                targetRot.setFromEuler(targetEuler);

                if (cardObj == draggedCardObj) {
                    var verticalScreenRangeForLayingCardMin = 0.2 - 0.4 * additionalFanOffsetFactor;
                    var verticalScreenRangeForLayingCardMax = 0.4 - 0.2 * additionalFanOffsetFactor;
                    var fanPlaneToTablePlaneBlendFactor = remapValueInRange(mouse.y, verticalScreenRangeForLayingCardMin, verticalScreenRangeForLayingCardMax, 0, 1);
                    fanPlaneToTablePlaneBlendFactor = clamp(fanPlaneToTablePlaneBlendFactor, 0, 1);

                    cardIsBeingDraggedOntoTable = fanPlaneToTablePlaneBlendFactor > 0;

                    var handContainerInvMatrix = handContainer.matrixWorld.clone();
                    handContainerInvMatrix.invert();

                    // World space ray
                    var pointerRay = raycaster.ray.clone();

                    var targetPositionInTablePlane = new THREE.Vector3();
                    pointerRay.intersectPlane(tablePlane, targetPositionInTablePlane);
                    targetPositionInTablePlane.y = 0.2; // height above table
                    targetPositionInTablePlane.applyMatrix4(handContainerInvMatrix);

                    // Convert pointerRay to hand container space
                    pointerRay.applyMatrix4(handContainerInvMatrix);

                    var cardDragPlane = new THREE.Plane(forward, targetPos.z);
                    var targetPositionInFanPlane = new THREE.Vector3();
                    pointerRay.intersectPlane(cardDragPlane, targetPositionInFanPlane);

                    // Blend between targetPositionInFanPlane & targetPositionInTablePlane
                    targetPos = targetPositionInFanPlane.clone();
                    targetPos.lerp(targetPositionInTablePlane, fanPlaneToTablePlaneBlendFactor);

                    var straightCardEuler = new THREE.Euler(
                        Math.PI / 2,
                        /*Math.PI*/ 0,
                        Math.PI
                    );
                    var straightCardRot = new THREE.Quaternion();
                    straightCardRot.setFromEuler(straightCardEuler);

                    var handContainerRotationInvMatrix = new THREE.Matrix4();
                    handContainerRotationInvMatrix.extractRotation(handContainerInvMatrix);
                    
                    var tableForwardInFanSpace = forward.clone();
                    tableForwardInFanSpace.applyMatrix4(handContainerRotationInvMatrix);

                    var hoveringCardRotation = new THREE.Quaternion();
                    hoveringCardRotation.setFromUnitVectors(up, tableForwardInFanSpace);
                    //targetRot.premultiply(hoveringCardRotation);
                    hoveringCardRotation.multiply(straightCardRot);

                    targetRot.slerp(hoveringCardRotation, fanPlaneToTablePlaneBlendFactor);

                    var lerpFactor = clamp(16.0 * delta, 0, 1);
                    if (cardIsBeingDraggedOntoTable) {
                        lerpFactor = 1;
                    }
                    
                    cardObj.position.lerp(targetPos, lerpFactor);
                    cardObj.position.setZ(targetPos.z);
                    //cardObj.quaternion.slerp(targetRot, lerpFactor);
                    cardObj.quaternion.copy(targetRot);
                } else {
                    var lerpFactor = clamp(8.0 * delta, 0, 1);

                    cardObj.position.lerp(targetPos, lerpFactor);
                    cardObj.quaternion.slerp(targetRot, lerpFactor);
                }
            }
        }
    }

    function updateDeck() {

    }

    function initLights() {
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
        var dirLight = new THREE.DirectionalLight(0xcceeff, 0.9);
        //dirLight.castShadow = true;
        dirLight.position.setScalar(5);
        dirLight.rotation.set(-45 * Math.PI / 180, 0 * Math.PI / 180);
        scene.add(dirLight, ambientLight);
    }

    /*function createCardMesh() {
        var faceUpTexture = txtLoader.load('card_front.jpg');
        var faceDownTexture = txtLoader.load('card_back.webp');
        // faceUpTexture.flipY = false;
        var darkMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
        var faceUpMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceUpTexture,
            shininess: 40
        });
        var faceDownMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceDownTexture,
            shininess: 40
        });
        var cardMesh = new THREE.Mesh(
            new THREE.BoxBufferGeometry(2, 0.04, 2),
            [
                darkMaterial, // left
                darkMaterial, // right
                faceDownMaterial, // facedown
                faceUpMaterial, // faceup
                darkMaterial, // 
                darkMaterial, // 
            ]
        );
        cardMesh.scale.x = 0.65;
        //cardMesh.castShadow = true;
        return cardMesh;
    }*/

    function initCard() {
        var card = cardMesh.clone();

        var facePlane = card.getObjectByName("FacePlane");
        facePlane.material = facePlane.material.clone();

        var signPlane = card.getObjectByName("SignPlane");
        var signPlane2 = card.getObjectByName("SignPlane2");
        signPlane.material = signPlane.material.clone();
        signPlane2.material = signPlane.material;

        var signPlane3 = card.getObjectByName("SignPlane3");
        var signPlane4 = card.getObjectByName("SignPlane4");
        signPlane3.material = signPlane.material.clone();
        signPlane4.material = signPlane3.material;

        //scene.add(card);

        // Animation 
        card.faceUp = false;
        card.mixer = new THREE.AnimationMixer(card);

        card.actions = {
            flipUpside: card.mixer.clipAction(flipUpsideClip),
            flipDownside: card.mixer.clipAction(flipDownsideClip),
            addToHand: card.mixer.clipAction(addToHandClip),
        };
        card.actions.flipUpside.loop = THREE.LoopOnce;
        card.actions.flipDownside.loop = THREE.LoopOnce;
        card.actions.flipUpside.clampWhenFinished = true;
        card.actions.flipDownside.clampWhenFinished = true;

        card.actions.addToHand.loop = THREE.LoopOnce;
        card.actions.addToHand.clampWhenFinished = true;

        return card;
    }

    function initTransferSlot() {
        const sizeX = 0.892;
        const sizeY = 1.313;
        const planeScale = 1.56;
        const spriteScale = 3;
        const iconSize = 0.75;

        transferSlot = new THREE.Group();

        var transferSlotPlane = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(1, 1),
            new THREE.RawShaderMaterial({
                uniforms: {
                    map       : { value: txtLoader.load("card_slot_bg.png") },
                    scale     : { value: new THREE.Vector2(spriteScale, spriteScale * sizeY / sizeX) }
                },
                vertexShader: document.getElementById('nineSliceVertShader').textContent,
                fragmentShader: document.getElementById('nineSliceFragShader').textContent,
                transparent: true
            })
        );

        transferSlotPlane.rotation.set(-Math.PI * 0.5, 0, 0);
        transferSlotPlane.scale.set(sizeX * planeScale, sizeY * planeScale, 1);
        transferSlot.add(transferSlotPlane);

        var transferIcon = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(iconSize, iconSize),
            new THREE.MeshStandardMaterial({
                map: txtLoader.load("icon_transition_mode_white_shadow_black.png"),
                metalness: 0,
                roughness: 1,
                transparent: true
            })
        );
        transferIcon.geometry.rotateX(-Math.PI * 0.5);
        transferIcon.position.set(0, 0.01, 0);

        transferSlot.add(transferIcon);

        //ground.receiveShadow = true;
        scene.add(transferSlot);
    }

    function initGround() {
        ground = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(15, 15),
            new THREE.MeshStandardMaterial({
                map: txtLoader.load("test_table.png"),
                metalness: 0,
                roughness: 1
            })
        );
        ground.geometry.rotateX(-Math.PI * 0.5);
        ground.position.set(0, -0.1, 1.0);
        //ground.receiveShadow = true;
        scene.add(ground);
    }

    function createFlipUpsideClip(side) { // 'faceup' or 'facedown'
        // Create a keyframe track (i.e. a timed sequence of keyframes) for each animated property
        // Note: the keyframe track type should correspond to the type of the property being animated
        // Rotation
        var zAxis = new THREE.Vector3(0, 0, 1);

        if (side === 'faceup') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
        } else if (side === 'facedown') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
        }

        var quaternionKF = new THREE.QuaternionKeyframeTrack(
            '.quaternion',
            [0, animationDuration],
            [qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w]
        );

        // Position
        var pointsArr = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(1, 0.8, 0),
            new THREE.Vector3(0.7, 1.5, 0),
            new THREE.Vector3(0.15, 1.2, 0),
            new THREE.Vector3(0, 0, 0)
        ];
        if (side === 'facedown') {
            pointsArr.forEach(function (vec3, i) {
                vec3.x = -vec3.x;
            });
        }
        var CRC = new THREE.CatmullRomCurve3(pointsArr, false, 'catmullrom', 0.9);
        var CRCPoints = CRC.getPoints(50);

        //var helper = pointsHelper(CRCPoints);
        //scene.add(helper); // Optional helper for position curve

        var posArrFlat = [];
        for (var i = 0; i < CRCPoints.length; i++) {
            posArrFlat.push(CRCPoints[i].x, CRCPoints[i].y, CRCPoints[i].z);
        }

        var timesArr = [];
        var len = posArrFlat.length - 3;
        for (var j = 0; j < posArrFlat.length / 3; j++) {
            var x = ((animationDuration / len) * j * 3) + 0; // + delay
            timesArr.push(x);
        }

        var positionKF = new THREE.VectorKeyframeTrack(
            '.position',
            timesArr,
            posArrFlat,
            THREE.InterpolateSmooth
        );

        var flipUpsideClip = new THREE.AnimationClip('Flip', animationDuration, [positionKF, quaternionKF]);

        return flipUpsideClip;
    }

    function createAddToHandClip() {
        var posArrFlat = [
            0, 0, 0,
            0, 0, -2.5,
            0, 0, 0
        ];

        var timesArr = [];
        var len = posArrFlat.length - 3;
        for (var j = 0; j < posArrFlat.length / 3; j++) {
            var x = ((animationDuration / len) * j * 3) + 0; // + delay
            timesArr.push(x);
        }

        var positionKF = new THREE.VectorKeyframeTrack(
            '.position',
            timesArr,
            posArrFlat,
            THREE.InterpolateSmooth
        );

        var clip = new THREE.AnimationClip('AddToHand', animationDuration, [positionKF]);

        return clip;
    }

    function absorbEvent(event) {
      var e = event || window.event;
      e.preventDefault && e.preventDefault();
      e.stopPropagation && e.stopPropagation();
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    }

    function onMouseMove(evt) {
        if (cardDragTouchId === null) {
            updateRaycaster();
        }

        /*if (raycast(card) == true) {
            card.material[2].color.set(colorLight);
            card.material[3].color.set(colorLight);
        } else {
            card.material[2].color.set(colorDark);
            card.material[3].color.set(colorDark);
        }*/

        return absorbEvent(evt);
    }

    function onMouseClick(evt) {
        //updateRaycaster();

        /*var cardObj = raycastCards();
        if (cardObj) {
            //flipCard(card);
        }*/

        return absorbEvent(evt);
    }

    function onMouseDown(evt) {
        console.log('down fired');
        console.log(evt);

        updateRaycaster();

        draggedCardObj = null;
        cardDragTouchId = null;
        var cardObj = raycastCards();
        if (cardObj) {
            if (cardIsInHand(cardObj, handContainer)) {
                draggedCardObj = cardObj;
                cardIsBeingDraggedOntoTable = false;
                /*var card = cardObj.children[0];
                flipCard(card);*/
            }
            
        }

        return absorbEvent(evt);
    }

    function onMouseUp(evt) {
        console.log('up fired');
        console.log(evt);

        if (draggedCardObj !== null && cardDragTouchId === null) {
            onDraggedCardReleased();
            draggedCardObj = null;
            cardDragTouchId = null;
        }

        return absorbEvent(evt);
    }

    function onTouchStart(evt) {
        console.log('touch start');
        console.log(evt);

        if (cardDragTouchId === null && evt.changedTouches.length == 1) {
            updateRaycaster(evt.changedTouches[0]);
            draggedCardObj = null;
            cardDragTouchId = null;
            var cardObj = raycastCards();
            if (cardObj) {
                if (cardIsInHand(cardObj, handContainer)) {
                    draggedCardObj = cardObj;
                    cardDragTouchId = evt.changedTouches[0].identifier;
                    cardIsBeingDraggedOntoTable = false;
                    /*var card = cardObj.children[0];
                    flipCard(card);*/
                }
            }
        }

        return absorbEvent(evt);
    }

    function onTouchEnd(evt) {
        console.log('touch end');
        console.log(evt);
        if (cardDragTouchId !== null) {
            for (var i = 0; i < evt.changedTouches.length; i++) {
                if (evt.changedTouches[i].identifier == cardDragTouchId) {
                    onDraggedCardReleased();
                    draggedCardObj = null;
                    cardDragTouchId = null;
                    break;
                }
            }
        }

        return absorbEvent(evt);
    }

    function onTouchMove(evt) {
        console.log('touch move');
        console.log(evt);
        if (cardDragTouchId !== null) {
            for (var i = 0; i < evt.changedTouches.length; i++) {
                if (evt.changedTouches[i].identifier == cardDragTouchId) {
                    updateRaycaster(evt.changedTouches[i]);
                    break;
                }
            }
        }

        return absorbEvent(evt);
    }

    function flipCard(card) {
        if (card.faceUp) { // card faceup
            // so turn it facedown
            card.actions.flipUpside.stop();
            card.actions.flipDownside.play();
            card.faceUp = false;
        } else if (!card.faceUp) { // card facedown
            // so turn it faceup
            card.actions.flipDownside.stop();
            card.actions.flipUpside.play();
            card.faceUp = true;
        }
    }

    function flipAllCards() {
        for (var i = 0; i < cards.length; i++) {
            flipCard(cards[i]);
        }
    }

    /*function raycast(object) {
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject(object);
        if (intersects.length > 0) {
            return true;
        } else {
            return false;
        }
    }*/

    function updateRaycaster(touch) {
        var clientX, clientY;
        if (touch) {
            clientX = touch.clientX;
            clientY = touch.clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);
    }

    function raycastCards() {
        /*// calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);*/

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects(cards, true);
        for (var i = 0; i < intersects.length; i++) {
            if (intersects[i].object.name == "CardBody") {
                return intersects[i].object.parent.parent;
            }
        }
        /*if (intersects.length > 0) {
            //console.log(intersects[0].object);
            return intersects[0].object.parent.parent;
        } else {
            return null;
        }*/
    }

    function remapValueInRange(v, a1, b1, a2, b2) {
        return a2 + (v - a1) / (b1 - a1) * (b2 - a2);
    }

    function clamp(v, min, max) {
        if (v < min) {
            return min;
        }
        if (v > max) {
            return max;
        }
        return v;
    }

    function pointsHelper(pointsArray) {
        var geometry = new THREE.BufferGeometry().setFromPoints(pointsArray);
        var material = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var curveObject = new THREE.Line(geometry, material);
        return curveObject;
    }

    function resize(renderer) {
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = canvas.clientWidth * pixelRatio | 0;
        const height = canvas.clientHeight * pixelRatio | 0;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
            renderer.setSize(width, height, false);
        }
        return needResize;
    }
</script>