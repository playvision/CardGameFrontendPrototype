<head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>

<style>
    html,
    body {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #c {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
    }

    #flipAllBtn {
        position: absolute;
        left: 5pt;
        top: 5pt;
        display: block;
    }
</style>

<canvas id="c" onclick=""></canvas>

<button id="flipAllBtn">Flip All</button>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

<script>
    // This example uses THREE.CatmullRomCurve3 to create a path for a custom Keyframe Track position animation. // helper

    // Global Variables
    var canvas, scene, renderer, camera;
    var controls, raycaster, mouse, txtLoader, clock, delta = 0;
    var cardMesh;
    var /*card,*/ ground;
    // animation clips
    var flipUpsideClip, flipDownsideClip;

    var cards = [];

    const colorDark = new THREE.Color(0xb0b0b0);
    const colorLight = new THREE.Color(0xffffff);
    const animationDuration = 1;

    init();

    function init() {
        canvas = document.querySelector('#c');

        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true
        });
        renderer.shadowMap.enabled = true;
        //canvas = renderer.domElement;
        //document.body.appendChild(canvas);

        camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera.position.set(0, 4, -1.5);
        controls = new THREE.OrbitControls(camera, canvas);

        canvas.addEventListener('mousemove', onMouseMove, false);
        canvas.addEventListener('click', onMouseClick, false);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        txtLoader = new THREE.TextureLoader();
        clock = new THREE.Clock();

        // Lights
        initLights();

        cardMesh = createCardMesh();

        // animation clips
        flipUpsideClip = createFlipUpsideClip('faceup');
        flipDownsideClip = createFlipUpsideClip('facedown');

        // Cards
        for (var x = -3; x <= 3; x++) {
            for (var z = -3; z <= 3; z++) {
                var card = initCard();
                var group = new THREE.Group();
                group.add(card);
                scene.add(group);
                group.position.set(1.4 * x, 0, 2.1 * z);
                cards.push(card);
            }
        }

        // Ground
        initGround();

        render();

        document.querySelector('#flipAllBtn').onclick = flipAllCards;
    }

    function render() {
        if (resize(renderer)) {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        delta = clock.getDelta();
        for (var i = 0; i < cards.length; i++) {
            cards[i].mixer.update(delta);
        }

        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    function initLights() {
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
        var dirLight = new THREE.DirectionalLight(0xcceeff, 0.9);
        dirLight.castShadow = true;
        dirLight.position.setScalar(5);
        scene.add(dirLight, ambientLight);
    }

    function createCardMesh() {
        var faceUpTexture = txtLoader.load('card_front.jpg');
        var faceDownTexture = txtLoader.load('card_back.webp');
        // faceUpTexture.flipY = false;
        var darkMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
        var faceUpMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceUpTexture,
            shininess: 40
        });
        var faceDownMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceDownTexture,
            shininess: 40
        });
        var cardMesh = new THREE.Mesh(
            new THREE.BoxBufferGeometry(2, 0.04, 2),
            [
                darkMaterial, // left
                darkMaterial, // right
                faceDownMaterial, // facedown
                faceUpMaterial, // faceup
                darkMaterial, // 
                darkMaterial, // 
            ]
        );
        cardMesh.scale.x = 0.65;
        cardMesh.castShadow = true;
        return cardMesh;
    }

    function initCard() {
        var card = cardMesh.clone();

        //scene.add(card);

        // Animation 
        card.faceUp = false;
        card.mixer = new THREE.AnimationMixer(card);

        card.actions = {
            flipUpside: card.mixer.clipAction(flipUpsideClip),
            flipDownside: card.mixer.clipAction(flipDownsideClip)
        };
        card.actions.flipUpside.loop = THREE.LoopOnce;
        card.actions.flipDownside.loop = THREE.LoopOnce;
        card.actions.flipUpside.clampWhenFinished = true;
        card.actions.flipDownside.clampWhenFinished = true;

        return card;
    }

    function initGround() {
        ground = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(15, 15),
            new THREE.MeshStandardMaterial({
                map: txtLoader.load("hardwood2_diffuse.jpg"),
                metalness: 0,
                roughness: 1
            })
        );
        ground.geometry.rotateX(-Math.PI * 0.5);
        ground.position.set(0, -0.1, 0);
        ground.receiveShadow = true;
        scene.add(ground);
    }

    function createFlipUpsideClip(side) { // 'faceup' or 'facedown'
        // Create a keyframe track (i.e. a timed sequence of keyframes) for each animated property
        // Note: the keyframe track type should correspond to the type of the property being animated
        // Rotation
        var zAxis = new THREE.Vector3(0, 0, 1);

        if (side === 'faceup') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
        } else if (side === 'facedown') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
        }

        var quaternionKF = new THREE.QuaternionKeyframeTrack(
            '.quaternion',
            [0, animationDuration],
            [qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w]
        );

        // Position
        var pointsArr = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(1, 0.8, 0),
            new THREE.Vector3(0.7, 1.5, 0),
            new THREE.Vector3(0.15, 1.2, 0),
            new THREE.Vector3(0, 0, 0)
        ];
        if (side === 'facedown') {
            pointsArr.forEach(function (vec3, i) {
                vec3.x = -vec3.x;
            });
        }
        var CRC = new THREE.CatmullRomCurve3(pointsArr, false, 'catmullrom', 0.9);
        var CRCPoints = CRC.getPoints(50);

        //var helper = pointsHelper(CRCPoints);
        //scene.add(helper); // Optional helper for position curve

        var posArrFlat = [];
        for (var i = 0; i < CRCPoints.length; i++) {
            posArrFlat.push(CRCPoints[i].x, CRCPoints[i].y, CRCPoints[i].z);
        }

        var timesArr = [];
        var len = posArrFlat.length - 3;
        for (var j = 0; j < posArrFlat.length / 3; j++) {
            var x = ((animationDuration / len) * j * 3) + 0; // + delay
            timesArr.push(x);
        }

        var positionKF = new THREE.VectorKeyframeTrack(
            '.position',
            timesArr,
            posArrFlat,
            THREE.InterpolateSmooth
        );

        var flipUpsideClip = new THREE.AnimationClip('Flip', animationDuration, [positionKF, quaternionKF]);

        return flipUpsideClip;
    }

    function onMouseMove(evt) {
        
        /*if (raycast(card) == true) {
            card.material[2].color.set(colorLight);
            card.material[3].color.set(colorLight);
        } else {
            card.material[2].color.set(colorDark);
            card.material[3].color.set(colorDark);
        }*/
    }

    function onMouseClick(evt) {
        var card = raycastCards();
        if (card) {
            flipCard(card);
        }
    }

    function flipCard(card) {
        if (card.faceUp) { // card faceup
            // so turn it facedown
            card.actions.flipUpside.stop();
            card.actions.flipDownside.play();
            card.faceUp = false;
        } else if (!card.faceUp) { // card facedown
            // so turn it faceup
            card.actions.flipDownside.stop();
            card.actions.flipUpside.play();
            card.faceUp = true;
        }
    }

    function flipAllCards() {
        for (var i = 0; i < cards.length; i++) {
            flipCard(cards[i]);
        }
    }

    function raycast(object) {
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject(object);
        if (intersects.length > 0) {
            return true;
        } else {
            return false;
        }
    }

    function raycastCards() {
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects(cards);
        if (intersects.length > 0) {
            return intersects[0].object;
        } else {
            return null;
        }
    }

    function pointsHelper(pointsArray) {
        var geometry = new THREE.BufferGeometry().setFromPoints(pointsArray);
        var material = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var curveObject = new THREE.Line(geometry, material);
        return curveObject;
    }

    function resize(renderer) {
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = canvas.clientWidth * pixelRatio | 0;
        const height = canvas.clientHeight * pixelRatio | 0;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
            renderer.setSize(width, height, false);
        }
        return needResize;
    }
</script>