<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
</head>

<style>
    html,
    body {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    #c {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
    }

    .testBtn {
        position: absolute;
        right: 5pt;
        top: 5pt;
        display: block;
        font-size: 20pt;
    }

    #options {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: block;
        padding: 5pt;
        background: #fff;
    }
</style>

<canvas id="c" onclick=""></canvas>

<!--<button id="flipAllBtn" class="testBtn">Flip All</button>-->
<button id="testBtn" class="testBtn">Click Me</button>

<div id="options">
    <p><input type="checkbox" id="option_gl1" name="option_gl1" /> <label for="option_gl1">Force WebGL 1</label></p>
    <p><input type="checkbox" id="option_pot" name="option_pot" /> <label for="option_pot"><s>(TODO) Use POT textures</s></label></p>
    <p><button id="startBtn">Start</button></p>
</div>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="Stats.js"></script>

<script>
    const gltfLoader = new THREE.GLTFLoader();

    var stats;

    // Global Variables
    var canvas, scene, renderer, camera;
    var controls, raycaster, mouse, txtLoader, clock, delta = 0;
    var cardMesh;
    var /*card,*/ ground;
    
    // animation clips
    var flipUpsideClip, flipDownsideClip, addToHandClip;

    var cards = [];
    var cardObjs = [];

    var deck = [];

    var transferSlot;

    var cameraAttachment;
    var handContainer;

    var draggedCardObj = null;
    var cardDragTouchId = null;

    const colorDark = new THREE.Color(0xb0b0b0);
    const colorLight = new THREE.Color(0xffffff);
    const animationDuration = 1;

    const forward = new THREE.Vector3(0, 0, -1);
    const up = new THREE.Vector3(0, 1, 0);

    const tablePlane = new THREE.Plane(up, 0);

    start();
    document.querySelector('#startBtn').addEventListener('click', start, false);

    function start() {
        document.querySelector('#options').style.display = 'none';
        gltfLoader.load(
            'card.glb',
            function (gltf) {
                // gltf.scene.traverse(function (child) {
                //     if ((child as THREE.Mesh).isMesh) {
                //         const m = (child as THREE.Mesh)
                //         m.receiveShadow = true
                //         m.castShadow = true
                //     }
                //     if (((child as THREE.Light)).isLight) {
                //         const l = (child as THREE.Light)
                //         l.castShadow = true
                //         l.shadow.bias = -.003
                //         l.shadow.mapSize.width = 2048
                //         l.shadow.mapSize.height = 2048
                //     }
                // })
                //scene.add(gltf.scene)
                
                /*var cardBody = gltf.scene;
                cardBody.name = "CardBody";
                cardBody.scale.set(0.004, 0.004, 0.004);
                cardBody.rotation.set(90 * Math.PI / 180, 0, 0);

                cardMesh = new THREE.Group();
                cardMesh.name = "Card";
                cardMesh.add(cardBody);*/

                var cardBody = gltf.scene.children[0];
                cardBody.name = "CardBody";
                cardBody.scale.set(0.004, 0.004, 0.004);
                cardBody.rotation.set(0, 0, 0);

                cardMesh = gltf.scene;
                cardMesh.name = "Card";

                /*cardMesh = gltf.scene;
                cardMesh.scale.set(0.004, 0.004, 0.004);*/

                init({
                    forceWebGL1: document.querySelector('#option_gl1').checked,
                    usePOTTextures: document.querySelector('#option_pot').checked,
                });
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            },
            (error) => {
                console.log(error)
            }
        );
    }

    function init(flags) {
        stats = new Stats();
        stats.showPanel( 0 );
        document.body.appendChild( stats.dom );

        canvas = document.querySelector('#c');

        scene = new THREE.Scene();

        const rendererClass = flags.forceWebGL1 ? THREE.WebGL1Renderer : THREE.WebGLRenderer;
        renderer = new rendererClass({
            canvas: canvas,
            antialias: true
        });

        console.log("isWebGL2? " + renderer.capabilities.isWebGL2);
        //renderer.shadowMap.enabled = true;
        //canvas = renderer.domElement;
        //document.body.appendChild(canvas);

        camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera.position.set(0, 7, 4);
        camera.rotation.set(-60 * Math.PI / 180, 0, 0);
        //controls = new THREE.OrbitControls(camera, canvas);

        canvas.addEventListener('mousemove', onMouseMove, false);
        canvas.addEventListener('click', onMouseClick, false);
        canvas.addEventListener('mousedown', onMouseDown, false);
        canvas.addEventListener('mouseup', onMouseUp, false);
        canvas.addEventListener('touchstart', onTouchStart, false);
        canvas.addEventListener('touchend', onTouchEnd, false);
        canvas.addEventListener('touchmove', onTouchMove, false);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        txtLoader = new THREE.TextureLoader();
        clock = new THREE.Clock();

        // Lights
        initLights();

        //cardMesh = createCardMesh();

        // animation clips
        flipUpsideClip = createFlipUpsideClip('faceup');
        flipDownsideClip = createFlipUpsideClip('facedown');
        addToHandClip = createAddToHandClip();

        // Cards
        /*for (var x = -3; x <= 3; x++) {
            for (var z = -3; z <= 3; z++) {
                var card = initCard();
                var group = new THREE.Group();
                group.add(card);
                scene.add(group);
                group.position.set(1.4 * x, 0, 2.1 * z);
                cards.push(card);
                cardObjs.push(group);
            }
        }*/

        // Cards
        for (var i = 0; i < 52; i++) {
            var card = initCard();
            var group = new THREE.Group();
            group.add(card);
            scene.add(group);
            cards.push(card);
            cardObjs.push(group);
        }

        // Transfer slot
        initTransferSlot();

        // Deck
        var heightOfCardInDeck = 0.02;
        var deckPos = new THREE.Vector3(-4.0, 0, -1.5);
        var deckEuler = new THREE.Euler(
            0,//Math.PI / 2,
            0,//Math.PI,
            Math.PI
        );
        var deckRot = new THREE.Quaternion();
        deckRot.setFromEuler(deckEuler);
        for (var i = 0; i < cardObjs.length; i++) {
            deck.push(cardObjs[i]);
            var cardPos = new THREE.Vector3(0, i * heightOfCardInDeck, 0);
            cardPos.add(deckPos);
            cardObjs[i].position.copy(cardPos);
        }

        // Camera attachment (container for camera-aligned objects)
        cameraAttachment = new THREE.Group();
        scene.add(cameraAttachment);
        updateCameraAttachment();

        // Hand container
        handContainer = new THREE.Group();
        cameraAttachment.add(handContainer);
        handContainer.position.set(0, -1.5, -4);

        // Create 6 table slots
        for (var i = 0; i < 6; i++) {
            tableSlots.push(
                {bottom: null, top: null}
            );
        }

        // Ground
        initGround();

        render();

        //document.querySelector('#flipAllBtn').onclick = flipAllCards;
        document.querySelector('#testBtn').onclick = addCard;
    }

    function addCardToHand(cardObj, handContainer) {
        handContainer.attach(cardObj);
        var card = cardObj.children[0];
        card.actions.addToHand.play();
    }

    function cardIsInHand(cardObj, handContainer) {
        return cardObj.parent == handContainer;
    }

    var tableSlots = [];

    function getFreeTableSlotIndex() {
        for (var i = 0; i < tableSlots.length; i++) {
            if (tableSlots[i].bottom === null) {
                return i;
            }
        }
        return -1;
    }

    function getNumberOfOccupiedTableSlots() {
        var i = getFreeTableSlotIndex();
        if (i == -1) {
            return tableSlots.length;
        }
        return i;
    }

    function tryPlaceCardOnTable(cardObj, slotIndex) {
        if (slotIndex == -1) {
            slotIndex = getFreeTableSlotIndex();
        }
        if (slotIndex == -1) {
            // No free slots
            return false;
        }
        var slot = tableSlots[slotIndex];
        if (slot.bottom === null) {
            slot.bottom = cardObj;
        } else if (slot.top === null) {
            slot.top = cardObj;
        } else {
            // The slot is occupied
            return false;
        }
        scene.attach(cardObj);
        return true;
    }

    function onCardDraggedOntoTable(cardObj) {
        tryPlaceCardOnTable(cardObj, -1);
    }

    function onDraggedCardReleased() {
        if (cardIsBeingDraggedOntoTable) {
            onCardDraggedOntoTable(draggedCardObj);
            cardIsBeingDraggedOntoTable = false;
        }
    }

    //var testCount = 0;
    function addCard() {
        var cardObj = deck.pop();
        if (cardObj) {
            addCardToHand(cardObj, handContainer);
        }
    }

    function updateCameraAttachment() {
        cameraAttachment.position.copy(camera.position);
        cameraAttachment.rotation.copy(camera.rotation);
    }

    function render() {
        stats.begin();

        if (resize(renderer)) {
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
        }

        delta = clock.getDelta();
        for (var i = 0; i < cards.length; i++) {
            cards[i].mixer.update(delta);
        }

        var transferSlotIsActive = true;

        const tableSlotsPerRow = 3;
        const offsetBetweenCols = 1.5;
        const offsetBetweenRows = 2.1;
        const centerPosition = new THREE.Vector3(0, 0, -1.5);
        var numProperTableSlots = getNumberOfOccupiedTableSlots();
        var numTableSlots = numProperTableSlots;
        if (transferSlotIsActive) {
            numTableSlots++;
        }
        var numRows = ~~(numTableSlots / tableSlotsPerRow) + ((numTableSlots % tableSlotsPerRow > 0) ? 1 : 0);
        for (var i = 0; i < numTableSlots; i++) {
            var slot = null;
            
            if (i <= numProperTableSlots - 1) {
                slot = tableSlots[i];
            }

            var row = ~~(i / tableSlotsPerRow);
            var col = i % tableSlotsPerRow;
            var numColsInRow = (row < numRows - 1)
                ? tableSlotsPerRow
                : (numTableSlots % tableSlotsPerRow || tableSlotsPerRow);

            var xOffset = -0.5 * offsetBetweenCols * (numColsInRow - 1);
            var zOffset = -1 * offsetBetweenRows * (numRows - 1);

            var targetPos = new THREE.Vector3(
                xOffset + col * offsetBetweenCols,
                0.01,
                zOffset + row * offsetBetweenRows
            );
            targetPos.add(centerPosition);

            var targetEuler = new THREE.Euler(
                0,//Math.PI / 2,
                0,//Math.PI,
                Math.PI
            );
            var targetRot = new THREE.Quaternion();
            targetRot.setFromEuler(targetEuler);

            var lerpFactor = clamp(8.0 * delta, 0, 1);

            if (slot) {
                slot.bottom.position.lerp(targetPos, lerpFactor);
                slot.bottom.quaternion.slerp(targetRot, lerpFactor);
            } else {
                transferSlot.position.lerp(targetPos, lerpFactor);
            }
        }

        updateCameraAttachment();

        var cardsInHandCount = handContainer.children.length;
        if (cardsInHandCount > 0) {
            var aspectRatioLimitForPositionAdjustment = 1.0;
            var aspectRatioLimitForSpreadAngleAdjustment = 1.4;

            var additionalFanOffset = new THREE.Vector3(0, 0, 0);
            var additionalFanOffsetFactor = 0;
            var maxAdditionalFanOffsetFactor = 0.8;
            if (camera.aspect < aspectRatioLimitForPositionAdjustment) {
                additionalFanOffsetFactor = aspectRatioLimitForPositionAdjustment / camera.aspect - 1;
                if (additionalFanOffsetFactor > maxAdditionalFanOffsetFactor) {
                    additionalFanOffsetFactor = maxAdditionalFanOffsetFactor;
                }
                additionalFanOffset.set(0, -1.0 * additionalFanOffsetFactor, -1.0 * additionalFanOffsetFactor);
            }

            var fanRadius = 5.0;
            var angleStep = -10;

            var maxFanSpreadAngle = 45;
            if (camera.aspect < aspectRatioLimitForSpreadAngleAdjustment) {
                maxFanSpreadAngle *= camera.aspect / aspectRatioLimitForSpreadAngleAdjustment;
            }
            var fanSpreadMul = maxFanSpreadAngle / (cardsInHandCount * Math.abs(angleStep));
            if (fanSpreadMul < 1) {
                angleStep *= fanSpreadMul;
            }

            var angleOffset = -0.5 * angleStep * (cardsInHandCount - 1);
            angleStep *= Math.PI / 180;
            angleOffset *= Math.PI / 180;
            var angleOffset2 = Math.PI / 2;
            for (var i = 0; i < cardsInHandCount; i++) {
                var cardObj = handContainer.children[i];

                var angle = angleOffset + i * angleStep;
                var depth = i * 0.02;
                var targetPos = new THREE.Vector3(
                    fanRadius * Math.cos(angleOffset2 + angle),
                    fanRadius * (Math.sin(angleOffset2 + angle) - 1),
                    depth
                );
                targetPos.add(additionalFanOffset);
                var targetEuler = new THREE.Euler(
                    Math.PI / 2,
                    /*Math.PI*/ 0 + angle,
                    Math.PI
                );
                var targetRot = new THREE.Quaternion();
                targetRot.setFromEuler(targetEuler);

                if (cardObj == draggedCardObj) {
                    var verticalScreenRangeForLayingCardMin = 0.2 - 0.4 * additionalFanOffsetFactor;
                    var verticalScreenRangeForLayingCardMax = 0.4 - 0.2 * additionalFanOffsetFactor;
                    var fanPlaneToTablePlaneBlendFactor = remapValueInRange(mouse.y, verticalScreenRangeForLayingCardMin, verticalScreenRangeForLayingCardMax, 0, 1);
                    fanPlaneToTablePlaneBlendFactor = clamp(fanPlaneToTablePlaneBlendFactor, 0, 1);

                    cardIsBeingDraggedOntoTable = fanPlaneToTablePlaneBlendFactor > 0;

                    var handContainerInvMatrix = handContainer.matrixWorld.clone();
                    handContainerInvMatrix.invert();

                    // World space ray
                    var pointerRay = raycaster.ray.clone();

                    var targetPositionInTablePlane = new THREE.Vector3();
                    pointerRay.intersectPlane(tablePlane, targetPositionInTablePlane);
                    targetPositionInTablePlane.y = 0.2; // height above table
                    targetPositionInTablePlane.applyMatrix4(handContainerInvMatrix);

                    // Convert pointerRay to hand container space
                    pointerRay.applyMatrix4(handContainerInvMatrix);

                    var cardDragPlane = new THREE.Plane(forward, targetPos.z);
                    var targetPositionInFanPlane = new THREE.Vector3();
                    pointerRay.intersectPlane(cardDragPlane, targetPositionInFanPlane);

                    // Blend between targetPositionInFanPlane & targetPositionInTablePlane
                    targetPos = targetPositionInFanPlane.clone();
                    targetPos.lerp(targetPositionInTablePlane, fanPlaneToTablePlaneBlendFactor);

                    var straightCardEuler = new THREE.Euler(
                        Math.PI / 2,
                        /*Math.PI*/ 0,
                        Math.PI
                    );
                    var straightCardRot = new THREE.Quaternion();
                    straightCardRot.setFromEuler(straightCardEuler);

                    var handContainerRotationInvMatrix = new THREE.Matrix4();
                    handContainerRotationInvMatrix.extractRotation(handContainerInvMatrix);
                    
                    var tableForwardInFanSpace = forward.clone();
                    tableForwardInFanSpace.applyMatrix4(handContainerRotationInvMatrix);

                    var hoveringCardRotation = new THREE.Quaternion();
                    hoveringCardRotation.setFromUnitVectors(up, tableForwardInFanSpace);
                    //targetRot.premultiply(hoveringCardRotation);
                    hoveringCardRotation.multiply(straightCardRot);

                    targetRot.slerp(hoveringCardRotation, fanPlaneToTablePlaneBlendFactor);

                    var lerpFactor = clamp(16.0 * delta, 0, 1);
                    if (cardIsBeingDraggedOntoTable) {
                        lerpFactor = 1;
                    }
                    
                    cardObj.position.lerp(targetPos, lerpFactor);
                    cardObj.position.setZ(targetPos.z);
                    //cardObj.quaternion.slerp(targetRot, lerpFactor);
                    cardObj.quaternion.copy(targetRot);
                }
                else
                {
                    var lerpFactor = clamp(8.0 * delta, 0, 1);

                    cardObj.position.lerp(targetPos, lerpFactor);
                    cardObj.quaternion.slerp(targetRot, lerpFactor);
                }
            }
        }

        renderer.render(scene, camera);

        stats.end();

        requestAnimationFrame(render);
    }

    function initLights() {
        var ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
        var dirLight = new THREE.DirectionalLight(0xcceeff, 0.9);
        //dirLight.castShadow = true;
        dirLight.position.setScalar(5);
        dirLight.rotation.set(-45 * Math.PI / 180, 0 * Math.PI / 180);
        scene.add(dirLight, ambientLight);
    }

    /*function createCardMesh() {
        var faceUpTexture = txtLoader.load('card_front.jpg');
        var faceDownTexture = txtLoader.load('card_back.webp');
        // faceUpTexture.flipY = false;
        var darkMaterial = new THREE.MeshPhongMaterial({ color: 0x111111 });
        var faceUpMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceUpTexture,
            shininess: 40
        });
        var faceDownMaterial = new THREE.MeshPhongMaterial({
            color: colorDark,
            map: faceDownTexture,
            shininess: 40
        });
        var cardMesh = new THREE.Mesh(
            new THREE.BoxBufferGeometry(2, 0.04, 2),
            [
                darkMaterial, // left
                darkMaterial, // right
                faceDownMaterial, // facedown
                faceUpMaterial, // faceup
                darkMaterial, // 
                darkMaterial, // 
            ]
        );
        cardMesh.scale.x = 0.65;
        //cardMesh.castShadow = true;
        return cardMesh;
    }*/

    function initCard() {
        var card = cardMesh.clone();

        //scene.add(card);

        // Animation 
        card.faceUp = false;
        card.mixer = new THREE.AnimationMixer(card);

        card.actions = {
            flipUpside: card.mixer.clipAction(flipUpsideClip),
            flipDownside: card.mixer.clipAction(flipDownsideClip),
            addToHand: card.mixer.clipAction(addToHandClip),
        };
        card.actions.flipUpside.loop = THREE.LoopOnce;
        card.actions.flipDownside.loop = THREE.LoopOnce;
        card.actions.flipUpside.clampWhenFinished = true;
        card.actions.flipDownside.clampWhenFinished = true;

        card.actions.addToHand.loop = THREE.LoopOnce;
        card.actions.addToHand.clampWhenFinished = true;

        return card;
    }

    function initTransferSlot() {
        transferSlot = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(0.892 * 1.5, 1.313 * 1.5),
            new THREE.MeshStandardMaterial({
                map: txtLoader.load("card_slot_bg.png"),
                metalness: 0,
                roughness: 1
            })
        );
        transferSlot.geometry.rotateX(-Math.PI * 0.5);

        var transferIcon = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(0.4 * 1.5, 0.4 * 1.5),
            new THREE.MeshStandardMaterial({
                map: txtLoader.load("icon_transition_mode_white_shadow_black.png"),
                metalness: 0,
                roughness: 1
            })
        );
        transferIcon.geometry.rotateX(-Math.PI * 0.5);
        transferIcon.position.set(0, 0.01, 0);

        transferSlot.add(transferIcon);

        //ground.receiveShadow = true;
        scene.add(transferSlot);
    }

    function initGround() {
        ground = new THREE.Mesh(
            new THREE.PlaneBufferGeometry(15, 15),
            new THREE.MeshStandardMaterial({
                map: txtLoader.load("hardwood2_diffuse.jpg"),
                metalness: 0,
                roughness: 1
            })
        );
        ground.geometry.rotateX(-Math.PI * 0.5);
        ground.position.set(0, -0.1, 0);
        //ground.receiveShadow = true;
        scene.add(ground);
    }

    function createFlipUpsideClip(side) { // 'faceup' or 'facedown'
        // Create a keyframe track (i.e. a timed sequence of keyframes) for each animated property
        // Note: the keyframe track type should correspond to the type of the property being animated
        // Rotation
        var zAxis = new THREE.Vector3(0, 0, 1);

        if (side === 'faceup') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
        } else if (side === 'facedown') {
            var qInitial = new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI);
            var qFinal = new THREE.Quaternion().setFromAxisAngle(zAxis, 0);
        }

        var quaternionKF = new THREE.QuaternionKeyframeTrack(
            '.quaternion',
            [0, animationDuration],
            [qInitial.x, qInitial.y, qInitial.z, qInitial.w, qFinal.x, qFinal.y, qFinal.z, qFinal.w]
        );

        // Position
        var pointsArr = [
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(1, 0.8, 0),
            new THREE.Vector3(0.7, 1.5, 0),
            new THREE.Vector3(0.15, 1.2, 0),
            new THREE.Vector3(0, 0, 0)
        ];
        if (side === 'facedown') {
            pointsArr.forEach(function (vec3, i) {
                vec3.x = -vec3.x;
            });
        }
        var CRC = new THREE.CatmullRomCurve3(pointsArr, false, 'catmullrom', 0.9);
        var CRCPoints = CRC.getPoints(50);

        //var helper = pointsHelper(CRCPoints);
        //scene.add(helper); // Optional helper for position curve

        var posArrFlat = [];
        for (var i = 0; i < CRCPoints.length; i++) {
            posArrFlat.push(CRCPoints[i].x, CRCPoints[i].y, CRCPoints[i].z);
        }

        var timesArr = [];
        var len = posArrFlat.length - 3;
        for (var j = 0; j < posArrFlat.length / 3; j++) {
            var x = ((animationDuration / len) * j * 3) + 0; // + delay
            timesArr.push(x);
        }

        var positionKF = new THREE.VectorKeyframeTrack(
            '.position',
            timesArr,
            posArrFlat,
            THREE.InterpolateSmooth
        );

        var flipUpsideClip = new THREE.AnimationClip('Flip', animationDuration, [positionKF, quaternionKF]);

        return flipUpsideClip;
    }

    function createAddToHandClip() {
        var posArrFlat = [
            0, 0, 0,
            0, 0, -2.5,
            0, 0, 0
        ];

        var timesArr = [];
        var len = posArrFlat.length - 3;
        for (var j = 0; j < posArrFlat.length / 3; j++) {
            var x = ((animationDuration / len) * j * 3) + 0; // + delay
            timesArr.push(x);
        }

        var positionKF = new THREE.VectorKeyframeTrack(
            '.position',
            timesArr,
            posArrFlat,
            THREE.InterpolateSmooth
        );

        var clip = new THREE.AnimationClip('AddToHand', animationDuration, [positionKF]);

        return clip;
    }

    function absorbEvent(event) {
      var e = event || window.event;
      e.preventDefault && e.preventDefault();
      e.stopPropagation && e.stopPropagation();
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    }

    function onMouseMove(evt) {
        if (cardDragTouchId === null) {
            updateRaycaster();
        }

        /*if (raycast(card) == true) {
            card.material[2].color.set(colorLight);
            card.material[3].color.set(colorLight);
        } else {
            card.material[2].color.set(colorDark);
            card.material[3].color.set(colorDark);
        }*/

        return absorbEvent(evt);
    }

    function onMouseClick(evt) {
        //updateRaycaster();

        /*var cardObj = raycastCards();
        if (cardObj) {
            //flipCard(card);
        }*/

        return absorbEvent(evt);
    }

    function onMouseDown(evt) {
        console.log('down fired');
        console.log(evt);

        updateRaycaster();

        draggedCardObj = null;
        cardDragTouchId = null;
        var cardObj = raycastCards();
        if (cardObj) {
            if (cardIsInHand(cardObj, handContainer)) {
                draggedCardObj = cardObj;
                cardIsBeingDraggedOntoTable = false;
                /*var card = cardObj.children[0];
                flipCard(card);*/
            }
            
        }

        return absorbEvent(evt);
    }

    function onMouseUp(evt) {
        console.log('up fired');
        console.log(evt);

        if (draggedCardObj !== null && cardDragTouchId === null) {
            onDraggedCardReleased();
            draggedCardObj = null;
            cardDragTouchId = null;
        }

        return absorbEvent(evt);
    }

    function onTouchStart(evt) {
        console.log('touch start');
        console.log(evt);

        if (cardDragTouchId === null && evt.changedTouches.length == 1) {
            updateRaycaster(evt.changedTouches[0]);
            draggedCardObj = null;
            cardDragTouchId = null;
            var cardObj = raycastCards();
            if (cardObj) {
                if (cardIsInHand(cardObj, handContainer)) {
                    draggedCardObj = cardObj;
                    cardDragTouchId = evt.changedTouches[0].identifier;
                    cardIsBeingDraggedOntoTable = false;
                    /*var card = cardObj.children[0];
                    flipCard(card);*/
                }
            }
        }

        return absorbEvent(evt);
    }

    function onTouchEnd(evt) {
        console.log('touch end');
        console.log(evt);
        if (cardDragTouchId !== null) {
            for (var i = 0; i < evt.changedTouches.length; i++) {
                if (evt.changedTouches[i].identifier == cardDragTouchId) {
                    onDraggedCardReleased();
                    draggedCardObj = null;
                    cardDragTouchId = null;
                    break;
                }
            }
        }

        return absorbEvent(evt);
    }

    function onTouchMove(evt) {
        console.log('touch move');
        console.log(evt);
        if (cardDragTouchId !== null) {
            for (var i = 0; i < evt.changedTouches.length; i++) {
                if (evt.changedTouches[i].identifier == cardDragTouchId) {
                    updateRaycaster(evt.changedTouches[i]);
                    break;
                }
            }
        }

        return absorbEvent(evt);
    }

    function flipCard(card) {
        if (card.faceUp) { // card faceup
            // so turn it facedown
            card.actions.flipUpside.stop();
            card.actions.flipDownside.play();
            card.faceUp = false;
        } else if (!card.faceUp) { // card facedown
            // so turn it faceup
            card.actions.flipDownside.stop();
            card.actions.flipUpside.play();
            card.faceUp = true;
        }
    }

    function flipAllCards() {
        for (var i = 0; i < cards.length; i++) {
            flipCard(cards[i]);
        }
    }

    /*function raycast(object) {
        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObject(object);
        if (intersects.length > 0) {
            return true;
        } else {
            return false;
        }
    }*/

    function updateRaycaster(touch) {
        var clientX, clientY;
        if (touch) {
            clientX = touch.clientX;
            clientY = touch.clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);
    }

    function raycastCards() {
        /*// calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);*/

        // calculate objects intersecting the picking ray
        var intersects = raycaster.intersectObjects(cards, true);
        for (var i = 0; i < intersects.length; i++) {
            if (intersects[i].object.name == "CardBody") {
                return intersects[i].object.parent.parent;
            }
        }
        /*if (intersects.length > 0) {
            //console.log(intersects[0].object);
            return intersects[0].object.parent.parent;
        } else {
            return null;
        }*/
    }

    function remapValueInRange(v, a1, b1, a2, b2) {
        return a2 + (v - a1) / (b1 - a1) * (b2 - a2);
    }

    function clamp(v, min, max) {
        if (v < min) {
            return min;
        }
        if (v > max) {
            return max;
        }
        return v;
    }

    function pointsHelper(pointsArray) {
        var geometry = new THREE.BufferGeometry().setFromPoints(pointsArray);
        var material = new THREE.LineBasicMaterial({ color: 0xff0000 });
        var curveObject = new THREE.Line(geometry, material);
        return curveObject;
    }

    function resize(renderer) {
        const canvas = renderer.domElement;
        const pixelRatio = window.devicePixelRatio;
        const width = canvas.clientWidth * pixelRatio | 0;
        const height = canvas.clientHeight * pixelRatio | 0;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
            renderer.setSize(width, height, false);
        }
        return needResize;
    }
</script>